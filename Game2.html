<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <!-- Phone-friendly: no zoom/scroll while playing -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Chicken Robot Jump ‚Äî Avoid the Obstacles!</title>
  <style>
    :root {
      --bg1: #0f172a; /* slate-900 */
      --bg2: #111827; /* gray-900 */
      --accent: #60a5fa; /* blue-400 */
      --accent-2: #34d399; /* emerald-400 */
      --danger: #f87171; /* red-400 */
      --ground: #1f2937; /* gray-800 */
      --hud: rgba(255,255,255,0.9);
    }
    * { box-sizing: border-box; touch-action: manipulation; }
    html, body { height: 100%; margin: 0; }
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans";
      background: radial-gradient(1200px 600px at 70% 10%, #1f2937 0%, var(--bg2) 40%, var(--bg1) 100%);
      color: white;
      display: grid;
      place-items: center;
      overscroll-behavior: none;
    }
    .frame {
      width: min(920px, 96vw);
      padding: 16px;
    }
    .header {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 10px;
    }
    h1 { font-size: clamp(20px, 2.6vw, 28px); margin: 0; letter-spacing: .3px; font-weight: 700; }
    .sub { opacity: .8; font-size: clamp(12px, 1.6vw, 14px); }

    .canvas-wrap {
      position: relative;
      border-radius: 16px;
      overflow: hidden;
      box-shadow: 0 10px 35px rgba(0,0,0,.45), 0 4px 10px rgba(0,0,0,.35);
      outline: 1px solid rgba(255,255,255,.06);
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.01));
    }

    #game {
      display: block;
      width: min(900px, 96vw);
      height: calc(min(900px, 96vw) * 0.4);
      image-rendering: pixelated;
      background: transparent;
      touch-action: none;
    }

    .hud {
      position: absolute;
      inset: 10px auto auto 10px;
      background: rgba(17,24,39,.55);
      padding: 8px 10px;
      border-radius: 10px;
      backdrop-filter: blur(4px);
      font-weight: 600;
      letter-spacing: .3px;
      z-index: 3;
    }
    .hud .score { color: var(--accent-2); }
    .hud .hiscore { color: var(--accent); opacity: .95; margin-left: 10px; }
    .hud .jumps { margin-left: 10px; color: #fbbf24; }
    .snd-btn { margin-left: 10px; font-weight: 700; font-size: 12px; padding: 4px 8px; border-radius: 8px; border: 1px solid rgba(255,255,255,.2); background: rgba(17,24,39,.55); color: white; cursor: pointer; }
    .snd-btn[aria-pressed="true"] { background: rgba(52,211,153,.25); border-color: rgba(16,185,129,.6); }

    .overlay {
      position: absolute; inset: 0;
      display: grid; place-items: center;
      background: radial-gradient(500px 280px at 50% 60%, rgba(0,0,0,.32), rgba(0,0,0,.62));
      color: white;
      text-align: center;
      padding: 20px;
      z-index: 2;
    }
    .panel {
      background: rgba(17,24,39,.72);
      border: 1px solid rgba(255,255,255,.08);
      border-radius: 16px;
      padding: 18px 20px;
      max-width: 520px;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.04), 0 20px 60px rgba(0,0,0,.35);
    }
    .panel h2 { margin: 0 0 8px 0; font-size: 22px; }
    .panel p { margin: 6px 0; opacity: .9; }
    kbd {
      background: rgba(255,255,255,.14);
      border: 1px solid rgba(255,255,255,.18);
      border-bottom-width: 2px;
      border-radius: 6px;
      padding: 2px 6px;
      font-weight: 700;
      box-shadow: inset 0 -1px 0 rgba(0,0,0,.25);
    }
    .small { font-size: 12px; opacity: .8; }
  </style>
</head>
<body>
  <div class="frame">
    <div class="header">
      <h1>Chicken Robot Jump ‚Äî Avoid the Obstacles!</h1>
      <div class="sub">Tap/click to start & jump ‚Ä¢ R to restart ‚Ä¢ M for sound</div>
    </div>

    <div class="canvas-wrap">
      <canvas id="game" width="900" height="360" aria-label="Chicken robot jumping game"></canvas>

      <div class="hud" id="hud">
        <span>Score: <span class="score" id="score">0</span></span>
        <span class="hiscore">Best: <span id="hiscore">0</span></span>
        <span class="jumps">Jumps: <span id="jumps">‚óè‚óè‚óè</span></span>
        <button class="snd-btn" id="sndBtn" aria-pressed="false" title="Toggle sound (M)">üîá Sound</button>
      </div>

      <div class="overlay" id="overlay">
        <div class="panel">
          <h2>Ready?</h2>
          <p>Help the chicken robot survive! Tap to jump over obstacles. Triple jump is enabled.</p>
          <p class="small" id="hint">Tap anywhere to start/jump. Keyboard also works: Space/‚Üë jump, R restart, M sound.</p>
        </div>
      </div>
    </div>
  </div>

  <script>
  (() => {
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const groundY = H - 60; // ground baseline

    // Block page scroll/zoom while touching canvas
    ['touchstart','touchmove','touchend','gesturestart'].forEach(evt =>
      document.addEventListener(evt, e => {
        if (e.target.closest('#game')) e.preventDefault();
      }, { passive: false })
    );

    // --- Simple WebAudio SFX ---
    const Audio = (() => {
      let ctxA = null, enabled = false;
      const ensure = async () => {
        if (!ctxA) ctxA = new (window.AudioContext || window.webkitAudioContext)();
        if (ctxA.state === 'suspended') await ctxA.resume();
      };
      const toggle = async () => { enabled = !enabled; if (enabled) await ensure(); return enabled; };
      const t = () => ctxA ? ctxA.currentTime : 0;
      const beep = (freq=440, dur=0.1, type='sine', vol=0.2) => {
        if (!enabled || !ctxA) return; const now = t();
        const o = ctxA.createOscillator(); const g = ctxA.createGain();
        o.type = type; o.frequency.value = freq; o.connect(g); g.connect(ctxA.destination);
        g.gain.value = vol; o.start(now); o.stop(now + dur);
        g.gain.exponentialRampToValueAtTime(0.0001, now + dur);
      };
      const chord = (freqs, dur=0.12, vol=0.08, type='triangle') => {
        if (!enabled || !ctxA) return; const now = t();
        const g = ctxA.createGain(); g.gain.value = vol; g.connect(ctxA.destination);
        freqs.forEach(f => { const o = ctxA.createOscillator(); o.type = type; o.frequency.value = f; o.connect(g); o.start(now); o.stop(now + dur); });
        g.gain.exponentialRampToValueAtTime(0.0001, now + dur);
      };
      return {
        toggle,
        jumpSfx: (lvl=0) => beep(520 + lvl*110, 0.08, 'square', 0.15),
        landSfx: () => chord([220, 330], 0.07, 0.05, 'triangle'),
        scoreSfx: () => chord([660, 880], 0.09, 0.06, 'square'),
        gameOver: () => chord([110, 82.41], 0.3, 0.08, 'sawtooth'),
        startSfx: () => chord([440, 660, 880], 0.12, 0.06, 'triangle')
      };
    })();

    // --- Game state ---
    let running = false;
    let gameOver = false;
    let last = 0; // timestamp
    let elapsed = 0; // total seconds
    const keys = Object.create(null);

    // World difficulty/speed
    let worldSpeed = 280; // px/s base
    const accelPerSec = 8; // speed increase per second

    // Player definition (chicken robot)
    const player = {
      x: 80,
      y: groundY - 42,
      w: 44,            // a bit wider for chicken body
      h: 42,
      standH: 42,
      duckH: 28,
      vx: 0,
      vy: 0,
      speed: 240,       // horizontal px/s (kept for keyboard users)
      jumpStrength: 520,// initial up velocity px/s
      onGround: true,
      duck: false,
      color: '#fcd34d', // chicken-yellow
      jumpsLeft: 3
    };

    let MAX_JUMPS = 3; // triple jump default
    const obstacles = [];
    let spawnTimer = 0; // seconds until next obstacle

    // Score
    let score = 0; let hiscore = Number(localStorage.getItem('robot_jump_hiscore') || 0);
    const scoreEl = document.getElementById('score');
    const hiscoreEl = document.getElementById('hiscore');
    const overlay = document.getElementById('overlay');
    const jumpsEl = document.getElementById('jumps');
    const sndBtn = document.getElementById('sndBtn');
    const hint = document.getElementById('hint');

    hiscoreEl.textContent = hiscore.toString();

    // Sound button
    const updateSndBtn = (on) => {
      sndBtn.setAttribute('aria-pressed', on ? 'true' : 'false');
      sndBtn.textContent = on ? 'üîä Sound' : 'üîá Sound';
    };
    sndBtn.addEventListener('click', async () => {
      const on = await Audio.toggle(); updateSndBtn(on); if (on) Audio.startSfx();
    });

    // --- Input handling (keyboard) for desktop ---
    function setKey(e, isDown) {
      const keyMap = { ' ': 'Space' };
      const k = keyMap[e.key] || e.key;
      if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"," ","Space"].includes(e.key)) {
        e.preventDefault();
      }
      keys[k] = isDown;

      if (isDown) {
        if (!running && (k === 'Space' || k === 'Enter')) startGame();
        if (running && (k === 'ArrowUp' || k === 'Space')) tryJump();
        if (k === 'r' || k === 'R') startGame();
        if (k === 'm' || k === 'M') sndBtn.click();
        if (k === '2') setMaxJumps(2);
        if (k === '3') setMaxJumps(3);
      }
    }
    window.addEventListener('keydown', e => setKey(e, true));
    window.addEventListener('keyup',   e => setKey(e, false));

    // --- Tap/click anywhere on canvas to start/jump (phones & desktop) ---
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      if (!running) startGame(); else tryJump();
    }, { passive:false });

    canvas.addEventListener('click', () => {
      if (!running) startGame(); else tryJump();
    });

    // Mobile hint text
    if (window.matchMedia('(hover: none) and (pointer: coarse)').matches) {
      hint.textContent = 'Tap anywhere to start and to jump. Triple jump is on!';
    }

    function setMaxJumps(n) {
      MAX_JUMPS = Math.max(1, Math.min(3, n));
      player.jumpsLeft = Math.min(player.jumpsLeft, MAX_JUMPS);
      updateJumpHud();
      const small = overlay.querySelector('.small');
      if (small) small.innerHTML = 'Tap to start/jump. Triple jump is available (press 2/3 on keyboard to change).';
    }

    function updateJumpHud() {
      jumpsEl.textContent = pips(player.jumpsLeft, MAX_JUMPS);
    }

    function pips(n, max) { return '‚óè'.repeat(n) + '‚óã'.repeat(Math.max(0, max - n)); }

    function tryJump() {
      if (player.jumpsLeft > 0 && !player.duck) {
        const levelUsed = MAX_JUMPS - player.jumpsLeft; // 0,1,2
        player.vy = -player.jumpStrength;
        player.onGround = false;
        player.jumpsLeft--;
        updateJumpHud();
        Audio.jumpSfx(levelUsed);
      }
    }

    function resetGame() {
      running = false; gameOver = false; last = performance.now(); elapsed = 0; score = 0; worldSpeed = 280;
      player.x = 80; player.standH = 42; player.duckH = 28; player.h = player.standH; player.y = groundY - player.h;
      player.vx = 0; player.vy = 0; player.onGround = true; player.duck = false; player.jumpsLeft = MAX_JUMPS;
      obstacles.length = 0; spawnTimer = 0.6; scoreEl.textContent = '0';
      overlay.style.display = 'grid';
      overlay.querySelector('h2').textContent = 'Ready?';
      updateJumpHud();
    }

    function startGame() {
      resetGame();
      overlay.style.display = 'none';
      running = true; last = performance.now();
      Audio.startSfx();
      requestAnimationFrame(loop);
    }

    function endGame() {
      running = false; gameOver = true; hiscore = Math.max(hiscore, Math.floor(score));
      localStorage.setItem('robot_jump_hiscore', String(hiscore)); hiscoreEl.textContent = String(hiscore);
      overlay.style.display = 'grid';
      const small = overlay.querySelector('.small');
      if (small) small.innerHTML = 'Tap to try again. (Keyboard: R restart, Space jump.)';
      Audio.gameOver();
    }

    let prevOnGround = true;

    function loop(ts) {
      if (!running) return;
      const dt = Math.min((ts - last) / 1000, 0.035); // clamp to avoid huge steps
      last = ts; elapsed += dt;
      update(dt); draw(); requestAnimationFrame(loop);
    }

    // --- Update world ---
    function update(dt) {
      // Difficulty ramps up
      worldSpeed += accelPerSec * dt;

      // Player movement (keyboard support kept; on phone you‚Äôll just tap to jump)
      const left  = !!keys['ArrowLeft'];
      const right = !!keys['ArrowRight'];
      const down  = !!keys['ArrowDown'];
      player.duck = down && player.onGround; // only duck on ground

      // Adjust height for duck/stand, keeping feet on ground
      const desiredH = player.duck ? player.duckH : player.standH;
      if (desiredH !== player.h) { const footY = player.y + player.h; player.h = desiredH; player.y = footY - player.h; }

      // Horizontal velocity (keyboard only)
      let dir = 0; if (left) dir -= 1; if (right) dir += 1; player.vx = dir * player.speed;

      // Apply gravity
      player.vy += 2000 * dt;

      // Integrate
      player.x += player.vx * dt; player.y += player.vy * dt;

      // Floor collision
      prevOnGround = player.onGround;
      if (player.y + player.h >= groundY) { player.y = groundY - player.h; player.vy = 0; player.onGround = true; }
      else { player.onGround = false; }

      // Landing detection for reset + sfx
      if (!prevOnGround && player.onGround) {
        if (player.jumpsLeft !== MAX_JUMPS) Audio.landSfx();
        player.jumpsLeft = MAX_JUMPS; updateJumpHud();
      }

      // Keep in-bounds
      const margin = 10; player.x = Math.max(margin, Math.min(W - margin - player.w, player.x));

      // Spawn obstacles
      spawnTimer -= dt;
      if (spawnTimer <= 0) {
        spawnObstacle();
        // Interval shrinks slightly as speed rises, with a minimum
        const base = 1.15, variance = 0.55; const speedFactor = Math.max(0.65, 1.0 - (worldSpeed - 280) / 1200);
        spawnTimer = (base + Math.random() * variance) * speedFactor;
      }

      // Move obstacles & check collisions
      for (let i = obstacles.length - 1; i >= 0; i--) {
        const o = obstacles[i];
        o.x -= (worldSpeed + o.speedBias) * dt;
        if (!o.passed && o.x + o.w < player.x) { o.passed = true; score += 5; Audio.scoreSfx(); }
        if (o.x + o.w < -10) { obstacles.splice(i, 1); continue; }
        if (rectsOverlap(player.x, player.y, player.w, player.h, o.x, o.y, o.w, o.h)) { endGame(); break; }
      }

      // Continuous score: survive time & speed bonus
      score += dt * (5 + worldSpeed * 0.02);
      scoreEl.textContent = String(Math.floor(score));
    }

    function spawnObstacle() {
      const maxH = 62, minH = 24; const h = Math.floor(minH + Math.random() * (maxH - minH));
      const w = Math.floor(24 + Math.random() * 36); const x = W + 40 + Math.random() * 120; const y = groundY - h;
      const speedBias = Math.random() * 40; const color = Math.random() < 0.25 ? '#f59e0b' : '#e5e7eb';
      obstacles.push({ x, y, w, h, color, passed: false, speedBias });
      if (Math.random() < 0.12) {
        const h2 = Math.floor(80 + Math.random() * 60);
        const w2 = Math.floor(18 + Math.random() * 20);
        const y2 = groundY - h2;
        obstacles.push({ x: x + 150, y: y2, w: w2, h: h2, color: '#a78bfa', passed: false, speedBias: speedBias + 10 });
      }
    }

    function rectsOverlap(ax, ay, aw, ah, bx, by, bw, bh) {
      return !(ax + aw <= bx || ax >= bx + bw || ay + ah <= by || ay >= by + bh);
    }

    // --- Rendering ---
    function draw() {
      // Sky gradient
      const g = ctx.createLinearGradient(0, 0, 0, H);
      g.addColorStop(0, '#0b1220'); g.addColorStop(1, '#0a0f1a');
      ctx.fillStyle = g; ctx.fillRect(0, 0, W, H);

      drawStars(); // background twinkles

      // Ground
      ctx.fillStyle = '#111827'; ctx.fillRect(0, groundY, W, H - groundY);
      ctx.fillStyle = '#1f2937'; ctx.fillRect(0, groundY, W, 4);

      // Obstacles
      for (const o of obstacles) drawBlock(o.x, o.y, o.w, o.h, o.color);

      // Player ‚Äî chicken robot
      drawChickenRobot(player.x, player.y, player.w, player.h);

      // Shadow
      ctx.globalAlpha = 0.18;
      const shadowW = Math.max(24, 48 - (player.y + player.h - groundY) * 0.08);
      ctx.beginPath(); ctx.ellipse(player.x + player.w * 0.5, groundY + 6, shadowW * 0.8, 6, 0, Math.PI * 2);
      ctx.fillStyle = 'black'; ctx.fill(); ctx.globalAlpha = 1;
    }

    function drawStars() {
      const t = (elapsed % 1000);
      for (let i = 0; i < 40; i++) {
        const x = (i * 97 + t * 7) % W;
        const y = (i * 53) % (groundY - 40);
        const r = (i % 7 === 0) ? 1.6 : 1.1;
        ctx.globalAlpha = (i % 5 === 0) ? 0.9 : 0.5;
        ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fillStyle = '#94a3b8'; ctx.fill();
        ctx.globalAlpha = 1;
      }
    }

    function drawBlock(x, y, w, h, color) {
      roundRect(x, y, w, h, Math.min(10, w * 0.25));
      const grad = ctx.createLinearGradient(x, y, x, y + h);
      grad.addColorStop(0, color); grad.addColorStop(1, shade(color, -20));
      ctx.fillStyle = grad; ctx.fill();
      ctx.globalAlpha = 0.25;
      roundRect(x+1, y+1, w-2, 6, 4); ctx.fillStyle = '#ffffff'; ctx.fill();
      ctx.globalAlpha = 1;
    }

    // --- Chicken Robot Drawing ---
    function drawChickenRobot(x, y, w, h) {
      // Body (yellow capsule)
      roundRect(x, y, w, h, 10);
      const body = ctx.createLinearGradient(x, y, x, y + h);
      body.addColorStop(0, '#fde68a'); body.addColorStop(1, '#f59e0b');
      ctx.fillStyle = body; ctx.fill();
      ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(0,0,0,.35)'; ctx.stroke();

      // Antenna (robot vibe)
      ctx.beginPath();
      ctx.moveTo(x + w*0.5, y - 6); ctx.lineTo(x + w*0.5, y + 2);
      ctx.strokeStyle = '#fef3c7'; ctx.lineWidth = 2; ctx.stroke();
      ctx.beginPath(); ctx.arc(x + w*0.5, y - 8, 3, 0, Math.PI * 2); ctx.fillStyle = '#fbbf24'; ctx.fill();

      // Comb (red)
      ctx.beginPath();
      ctx.moveTo(x + w*0.25, y + 2);
      ctx.quadraticCurveTo(x + w*0.32, y - 8, x + w*0.38, y + 2);
      ctx.quadraticCurveTo(x + w*0.45, y - 10, x + w*0.50, y + 2);
      ctx.fillStyle = '#ef4444'; ctx.fill();

      // Beak (orange triangle)
      ctx.beginPath();
      ctx.moveTo(x + w*0.82, y + h*0.48);
      ctx.lineTo(x + w*0.97, y + h*0.52);
      ctx.lineTo(x + w*0.82, y + h*0.58);
      ctx.closePath(); ctx.fillStyle = '#f97316'; ctx.fill();

      // Eyes (robotic dark with white spec)
      const dir = Math.sign(player.vx);
      const eyeOffsetX = 4 * dir;
      drawEye(x + w*0.62 + eyeOffsetX, y + h*0.38, 4);
      drawEye(x + w*0.48 + eyeOffsetX, y + h*0.42, 4);

      // Wing (dark panel)
      ctx.beginPath();
      ctx.roundRect(x + w*0.18, y + h*0.48, w*0.30, h*0.22, 6);
      ctx.fillStyle = 'rgba(0,0,0,.25)'; ctx.fill();

      // Metal ‚Äúleg plates‚Äù suggestion
      ctx.beginPath();
      ctx.roundRect(x + w*0.30, y + h*0.78, w*0.40, h*0.12, 4);
      ctx.fillStyle = 'rgba(0,0,0,.30)'; ctx.fill();
    }

    function drawEye(cx, cy, r) {
      ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI * 2); ctx.fillStyle = '#0f172a'; ctx.fill();
      ctx.beginPath(); ctx.arc(cx - r*0.3, cy - r*0.3, r*0.4, 0, Math.PI * 2); ctx.fillStyle = 'white'; ctx.fill();
    }

    function roundRect(x, y, w, h, r) {
      if (w <= 0 || h <= 0) return;
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.arcTo(x + w, y, x + w, y + h, r);
      ctx.arcTo(x + w, y + h, x, y + h, r);
      ctx.arcTo(x, y + h, x, y, r);
      ctx.arcTo(x, y, x + w, y, r);
      ctx.closePath();
    }

    function shade(hex, percent) {
      const a = hex.replace('#',''); const num = parseInt(a, 16);
      let r = (num >> 16) & 0xff, g = (num >> 8) & 0xff, b = num & 0xff;
      r = Math.min(255, Math.max(0, r + Math.round(255 * (percent/100))));
      g = Math.min(255, Math.max(0, g + Math.round(255 * (percent/100))));
      b = Math.min(255, Math.max(0, b + Math.round(255 * (percent/100))));
      return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    }

    // Kick off with a fresh state
    resetGame(); draw();
  })();
  </script>
</body>
</html>
